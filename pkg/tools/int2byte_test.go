package tools

import (
	"fmt"
	"testing"
)

func TestLittleEndian(t *testing.T) {
	var v3 uint32
	var b3 [4]byte
	v3 = 257
	// 将 256转成二进制就是
	// | 00000000 | 00000000 | 00000001 | 00000001 |
	// | b3[0]  | b3[1]  | b3[2]  | [3]   | // 这里表示b3数组每个下标里面存放的值

	// 这里直接使用将uint32l强转成uint8
	// | 00000000 0000000 00000001 | 00000001 直接转成uint8后等于 1
	// |---这部分go在强转的时候扔掉---|
	b3[0] = uint8(v3)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移8位 转成uint8后等于 1
	// 下面是右移后的数据
	// |     | 00000000 | 00000000 | 00000001 |
	b3[1] = uint8(v3 >> 8)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移16位 转成uint8后等于 0
	// 下面是右移后的数据
	// |     |     | 00000000 | 00000000 |
	b3[2] = uint8(v3 >> 16)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移24位 转成uint8后等于 0
	// 下面是右移后的数据
	// |     |     |     | 00000000 |
	b3[3] = uint8(v3 >> 24)

	fmt.Printf("%+v\n", b3)
	// 所以最终将uint32转成[]byte数组输出为
	// [1 1 0 0 ]
}

func TestBigEndian(t *testing.T) {
	var v2 uint32
	var b2 [4]byte
	v2 = 257
	// 将 257转成二进制就是
	// | 00000000 | 00000000 | 00000001 | 00000001 |
	// | b2[0]    | b2[1]    | b2[2]    | b2[3]    | // 这里表示b2数组每个下标里面存放的值

	// 这里直接使用将uint32强转成uint8
	// | 00000000 0000000 00000001 | 00000001  直接转成uint8后等于 1
	// |---这部分go在强转的时候扔掉---|
	b2[3] = uint8(v2)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移8位 转成uint8后等于 1
	// 下面是右移后的数据
	// |          | 00000000 | 00000000 | 00000001 |
	b2[2] = uint8(v2 >> 8)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移16位 转成uint8后等于 0
	// 下面是右移后的数据
	// |          |          | 00000000 | 00000000 |
	b2[1] = uint8(v2 >> 16)

	// | 00000000 | 00000000 | 00000001 | 00000001 | 右移24位 转成uint8后等于 0
	// 下面是右移后的数据
	// |          |          |          | 00000000 |
	b2[0] = uint8(v2 >> 24)

	fmt.Printf("%+v\n", b2)
	// 所以最终将uint32转成[]byte数组输出为
	// [0 0 1 1]
}
